# -*- coding: utf-8 -*-
"""movies_recommeder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jCwmeJyISM5gzGcRDzZ2M5ruQGvIErvA
"""

import pandas as pd

df=pd.read_csv("/content/movies_with_images.csv")
df.head()

df = df.dropna(subset=["overview", "genres", "cast", "director", "keywords"])
print("After cleaning:", df.shape)

import unicodedata

def normalize_text(t):
    if not isinstance(t, str):
        return ""
    t = unicodedata.normalize('NFKD', t).encode('ascii','ignore').decode('utf-8')
    return t.lower().strip()

def join_list(x):
    return " ".join(eval(x)) if isinstance(x, str) and x.startswith("[") else x

df["genres"] = df["genres"].apply(join_list)
df["cast"] = df["cast"].apply(join_list)
df["keywords"] = df["keywords"].apply(join_list)

df["title_norm"] = df["title"].apply(normalize_text)

df['genres']

df["combined_text"] = (
    df["overview"].fillna("") + " " +
    df["genres"].fillna("") + " " +
    df["keywords"].fillna("") + " " +
    df["cast"].fillna("") + " " +
    df["director"].fillna("")
)

df["combined_text"]

from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer(stop_words="english", max_features=5000)
tfidf_matrix = tfidf.fit_transform(df["combined_text"])

tfidf_matrix.shape

from sklearn.metrics.pairwise import cosine_similarity

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
cosine_sim.shape

from difflib import SequenceMatcher

def seq_ratio(a, b):
    return SequenceMatcher(None, a, b).ratio()

def jaccard(a_tokens, b_tokens):
    A, B = set(a_tokens), set(b_tokens)
    if not A or not B:
        return 0
    return len(A & B) / len(A | B)

df["title_tokens"] = df["title_norm"].apply(lambda t: t.split())

def find_movie(query):
    q = normalize_text(query)
    q_tokens = q.split()

    # -----------------------------------------
    # SPECIAL CASE: short titles (length <= 4)
    # -----------------------------------------
    if len(q) <= 4:
        # 1. exact normalized match
        exact = df[df["title_norm"] == q]
        if len(exact) > 0:
            return exact["title"].iloc[0]

        # 2. substring match (VERY STRONG)
        sub = df[df["title_norm"].str.contains(q)]
        if len(sub) > 0:
            # pick most popular movie
            return sub.sort_values("vote_count", ascending=False)["title"].iloc[0]

        # 3. prefix match
        pre = df[df["title_norm"].str.startswith(q)]
        if len(pre) > 0:
            return pre.sort_values("vote_count", ascending=False)["title"].iloc[0]

        # 4. last fallback: fuzzy on short titles
        best_title = None
        best_score = 0

        for _, row in df.iterrows():
            t = row["title_norm"]
            score = seq_ratio(q, t)
            if score > best_score:
                best_score = score
                best_title = row["title"]

        return best_title

    # -----------------------------------------
    # MAIN LOGIC for normal-sized titles
    # -----------------------------------------

    # 1. exact match
    exact = df[df["title_norm"] == q]
    if len(exact) > 0:
        return exact["title"].iloc[0]

    # 2. substring match
    sub = df[df["title_norm"].str.contains(q)]
    if len(sub) > 0:
        return sub.sort_values("vote_count", ascending=False)["title"].iloc[0]

    # 3. fuzzy scoring
    best_title = None
    best_score = 0

    for _, row in df.iterrows():
        t = row["title_norm"]
        score = 0.7 * jaccard(q_tokens, row["title_tokens"]) + 0.3 * seq_ratio(q, t)

        if score > best_score:
            best_score = score
            best_title = row["title"]

    return best_title

def recommend(movie_input, top_n=10):
    title = find_movie(movie_input)

    if title is None:
        return f"Movie '{movie_input}' not found."

    print("Matched:", title)

    idx = df.index[df["title"] == title][0]

    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1 : top_n+1]

    movie_indices = [i[0] for i in sim_scores]

    return df.iloc[movie_indices][["title", "genres", "rating", "poster_url"]]

recommend("12th fail")

from sklearn.metrics import precision_score, recall_score, f1_score
import numpy as np

def evaluate_recommender(k=10):
    true_positive = 0
    false_positive = 0
    false_negative = 0

    n = len(df)

    for idx in range(n):
        # TRUE SIMILAR MOVIES (top K from cosine_sim)
        true_scores = list(enumerate(cosine_sim[idx]))
        true_scores = sorted(true_scores, key=lambda x: x[1], reverse=True)[1:k+1]
        true_indices = [i[0] for i in true_scores]

        # MODEL PREDICTED MOVIES
        title = df.iloc[idx]["title"]
        pred_df = recommend(title, top_n=k)

        if isinstance(pred_df, str):
            continue

        pred_titles = pred_df["title"].tolist()
        pred_indices = [df.index[df["title"] == t][0] for t in pred_titles]

        # BUILD BINARY VECTORS
        true_vec = np.zeros(n)
        pred_vec = np.zeros(n)

        true_vec[true_indices] = 1
        pred_vec[pred_indices] = 1

        # ACCUMULATE RESULTS
        true_positive += np.sum((true_vec == 1) & (pred_vec == 1))
        false_positive += np.sum((true_vec == 0) & (pred_vec == 1))
        false_negative += np.sum((true_vec == 1) & (pred_vec == 0))

    # CALCULATE METRICS
    precision = true_positive / (true_positive + false_positive + 1e-6)
    recall = true_positive / (true_positive + false_negative + 1e-6)
    f1 = 2 * (precision * recall) / (precision + recall + 1e-6)

    print("Precision@{}: {:.4f}".format(k, precision))
    print("Recall@{}: {:.4f}".format(k, recall))
    print("F1-score@{}: {:.4f}".format(k, f1))

    return precision, recall, f1

evaluate_recommender(k=10)

def genre_precision_at_k(k=10):
    total = 0
    match = 0

    for idx in range(len(df)):
        title = df.iloc[idx]["title"]
        genres = set(df.iloc[idx]["genres"].split())

        preds = recommend(title, top_n=k)
        if isinstance(preds, str):
            continue

        for _, row in preds.iterrows():
            total += 1
            rec_genres = set(row["genres"].split())
            if len(genres & rec_genres) > 0:
                match += 1

    precision = match / total
    print(f"Genre Precision@{k}: {precision:.4f}")
    return precision

genre_precision_at_k(10)

